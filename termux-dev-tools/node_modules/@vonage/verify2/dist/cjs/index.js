"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/index.ts
var index_exports = {};
__export(index_exports, {
  Channels: () => Channels,
  EventStatus: () => EventStatus,
  RequestStatus: () => RequestStatus,
  RequestWorkflowStatus: () => RequestWorkflowStatus,
  SilentAuthChannel: () => SilentAuthChannel,
  SilentAuthStatus: () => SilentAuthStatus,
  Verify2: () => Verify2,
  VerifyLocale: () => VerifyLocale
});
module.exports = __toCommonJS(index_exports);

// lib/enums/channels.ts
var Channels = /* @__PURE__ */ ((Channels2) => {
  Channels2["SMS"] = "sms";
  Channels2["WHATSAPP"] = "whatsapp";
  Channels2["WHATSAPP_INTERACTIVE"] = "whatsapp_interactive";
  Channels2["VOICE"] = "voice";
  Channels2["RCS"] = "rcs";
  Channels2["EMAIL"] = "email";
  return Channels2;
})(Channels || {});
var SilentAuthChannel = /* @__PURE__ */ ((SilentAuthChannel2) => {
  SilentAuthChannel2["SILENT_AUTH"] = "silent_auth";
  return SilentAuthChannel2;
})(SilentAuthChannel || {});

// lib/enums/eventStatus.ts
var EventStatus = /* @__PURE__ */ ((EventStatus2) => {
  EventStatus2["COMPLETED"] = "completed";
  EventStatus2["FAILED"] = "failed";
  EventStatus2["USER_REJECTED"] = "user_rejected";
  EventStatus2["REJECTED"] = "rejected";
  return EventStatus2;
})(EventStatus || {});

// lib/enums/requestStatus.ts
var RequestStatus = /* @__PURE__ */ ((RequestStatus2) => {
  RequestStatus2["COMPLETED"] = "completed";
  RequestStatus2["FAILED"] = "failed";
  RequestStatus2["EXPIRED"] = "expired";
  return RequestStatus2;
})(RequestStatus || {});

// lib/enums/requestWorkflowsStatus.ts
var RequestWorkflowStatus = /* @__PURE__ */ ((RequestWorkflowStatus2) => {
  RequestWorkflowStatus2["UNUSED"] = "unused";
  RequestWorkflowStatus2["COMPLETED"] = "completed";
  RequestWorkflowStatus2["FAILED"] = "failed";
  RequestWorkflowStatus2["EXPIRED"] = "expired";
  RequestWorkflowStatus2["USER_REJECTED"] = "user_rejected";
  return RequestWorkflowStatus2;
})(RequestWorkflowStatus || {});

// lib/enums/silentAuthStatus.ts
var SilentAuthStatus = /* @__PURE__ */ ((SilentAuthStatus2) => {
  SilentAuthStatus2["COMPLETED"] = "completed";
  SilentAuthStatus2["FAILED"] = "failed";
  SilentAuthStatus2["USER_REJECTED"] = "user_rejected";
  SilentAuthStatus2["EXPIRED"] = "expired";
  SilentAuthStatus2["ACTION_PENDING"] = "action_pending";
  return SilentAuthStatus2;
})(SilentAuthStatus || {});

// lib/enums/verifyLocale.ts
var VerifyLocale = /* @__PURE__ */ ((VerifyLocale2) => {
  VerifyLocale2["EN_US"] = "en-us";
  VerifyLocale2["EN_GB"] = "en-gb";
  VerifyLocale2["ES_ES"] = "es-es";
  VerifyLocale2["ES_MX"] = "es-mx";
  VerifyLocale2["ES_US"] = "es-us";
  VerifyLocale2["IT_IT"] = "it-it";
  VerifyLocale2["FR_FR"] = "fr-fr";
  VerifyLocale2["DE_DE"] = "de-de";
  VerifyLocale2["RU_RU"] = "ru-ru";
  VerifyLocale2["HI_IN"] = "hi-in";
  VerifyLocale2["PT_BR"] = "pt-br";
  VerifyLocale2["PT_PT"] = "pt-pt";
  VerifyLocale2["ID_ID"] = "id-id";
  return VerifyLocale2;
})(VerifyLocale || {});

// lib/verify2.ts
var import_server_client = require("@vonage/server-client");
var Verify2 = class extends import_server_client.Client {
  /**
   * The authentication type used for this client (JWT).
   */
  authType = import_server_client.AuthenticationType.JWT;
  /**
   * Creates a new verification request.
   *
   * @param {VerificationRequestParams} params - The parameters for the
   *  verification request.
   * @return {Request} A `Request` object containing the request ID.
   */
  async newRequest(params) {
    const resp = await this.sendPostRequest(
      `${this.config.apiHost}/v2/verify`,
      import_server_client.Client.transformers.snakeCaseObjectKeys(params, true)
    );
    return {
      requestId: resp.data.request_id,
      checkUrl: resp.data.check_url
    };
  }
  /**
   * Checks a verification code against a verification request.
   * @param {string} requestId - The ID of the verification request.
   * @param {string} code - The verification code to check.
   * @return {string} The status of the verification code check.
   */
  async checkCode(requestId, code) {
    const resp = await this.sendPostRequest(
      `${this.config.apiHost}/v2/verify/${requestId}`,
      {
        code
      }
    );
    return resp.data.status;
  }
  /**
   * Cancels a verification request.
   * @param {string} requestId - The ID of the verification request to cancel.
   * @return {boolean} `true` if the cancellation was successful.
   */
  async cancel(requestId) {
    try {
      await this.sendDeleteRequest(
        `${this.config.apiHost}/v2/verify/${requestId}`
      );
      return true;
    } catch (_) {
      return false;
    }
  }
  /**
   * Generator function to list all templates across multiple pages.
   *
   * @remarks
   * This will continue calling the API to retrieve all templates until there are no more pages left.
   * The function yields each template in camelCase format.
   *
   * @param {ListAllTemplatesParams} [params={}] - Optional filter parameters, including pagination.
   * @yields {Template} - Yields each template object in camelCase format.
   *
   * @example
   * List all templates using pagination:
   * ```ts
   * for await (const template of templateClient.listAllTemplates({ pageSize: 5 })) {
   *   console.log(template.name);
   * }
   * ```
   *
   * @example
   * List all templates without pagination:
   * ```ts
   * for await (const template of templateClient.listAllTemplates()) {
   *   console.log(template.name);
   * }
   * ```
   */
  async *listAllTemplates(params = {}) {
    let next = null;
    params.page = params?.page || 1;
    do {
      const resp = await this.getTemplatePage(params);
      yield* resp.templates || [];
      next = resp.links?.next;
      params.page++;
    } while (next);
  }
  /**
   * Retrieves a single page of templates based on the provided pagination parameters.
   *
   * @param {ListAllTemplatesParams} params - The filter parameters for pagination (e.g., page number, page size).
   * @return {Promise<ListAllTemplatesResponse>} - A promise resolving to a page of templates.
   *
   * @example
   * Get a single page of templates:
   *
   * ```ts
   * const templatePage = await templateClient.getTemplatePage({
   *   page: 1,
   *   pageSize: 10
   * });
   *
   * templatePage.templates.forEach(template => {
   *   console.log(template.name);
   * });
   * ```
   */
  async getTemplatePage(params = {}) {
    const resp = await this.sendGetRequest(
      `${this.config.apiHost}/v2/verify/templates`,
      {
        ...params.page ? { page: params.page } : {},
        ...params.pageSize ? { page_size: params.pageSize } : {}
      }
    );
    const templates = (resp.data._embedded?.templates || []).map(
      (template) => import_server_client.Client.transformers.camelCaseObjectKeys(template)
    );
    return {
      pageSize: resp.data.page_size,
      page: resp.data.page,
      totalPages: resp.data.total_pages,
      totalItems: resp.data.total_items,
      templates,
      links: resp.data._links
    };
  }
  /**
   * Creates a new template with the provided details.
   *
   * @param {Template} template - The template details to be created.
   * @return {Promise<Template>} - A promise resolving to the created template in camelCase format.
   *
   * @example
   * Create a new template:
   * ```ts
   * const newTemplate = await templateClient.createTemplate({
   *   name: 'My New Template',
   * });
   * console.log(newTemplate.name);
   * ```
   */
  async createTemplate(template) {
    const resp = await this.sendPostRequest(
      `${this.config.apiHost}/v2/verify/templates`,
      {
        name: template.name
      }
    );
    return import_server_client.Client.transformers.camelCaseObjectKeys(resp.data);
  }
  /**
   * Retrieves a single template by its unique identifier.
   *
   * @param {string} templateId - The unique identifier of the template to retrieve.
   * @return {Promise<Template>} - A promise resolving to the retrieved template in camelCase format.
   *
   * @example
   * Get a template by ID:
   * ```ts
   * const template = await templateClient.getTemplate('22f571c1-f41a-4db2-bba7-f23a069200c1');
   * console.log(template.name);
   * ```
   */
  async getTemplate(templateId) {
    const resp = await this.sendGetRequest(
      `${this.config.apiHost}/v2/verify/templates/${templateId}`
    );
    return import_server_client.Client.transformers.camelCaseObjectKeys(resp.data);
  }
  /**
   * Deletes a template by its unique identifier.
   *
   * @param {string} templateId - The unique identifier of the template to delete.
   * @return {Promise<true>} - A promise that resolves when the template is successfully deleted.
   *
   * @example
   * Delete a template by ID:
   * ```ts
   * await templateClient.deleteTemplate('22f571c1-f41a-4db2-bba7-f23a069200c1');
   * console.log('Template deleted successfully');
   * ```
   */
  async deleteTemplate(templateId) {
    await this.sendDeleteRequest(
      `${this.config.apiHost}/v2/verify/templates/${templateId}`
    );
    return true;
  }
  /**
   * Updates an existing template with the provided details.
   *
   * @param {Template} template - The full template object with updated details. The template must include its ID.
   * @return {Promise<Template>} - A promise resolving to the updated template in camelCase format.
   *
   * @example
   * Update a template:
   * ```ts
   * const updatedTemplate = await templateClient.updateTemplate({
   *   templateId: '22f571c1-f41a-4db2-bba7-f23a069200c1',
   *   name: 'Updated Template Name',
   *   isDefault: false,
   * });
   * console.log(updatedTemplate.name);
   * ```
   */
  async updateTemplate(template) {
    if (!template.templateId) {
      throw new Error("Template ID is required for updating a template");
    }
    const resp = await this.sendPatchRequest(
      `${this.config.apiHost}/v2/verify/templates/${template.templateId}`,
      {
        name: template.name,
        is_default: template.isDefault || false
      }
    );
    return import_server_client.Client.transformers.camelCaseObjectKeys(resp.data);
  }
  /**
   * Retrieves a page of template fragments based on the provided pagination and filter parameters.
   *
   * @param {ListAllTemplateFragmentsQueryParams} params - The filter parameters for pagination (e.g., page number, page size, template ID).
   * @return {Promise<ListAllTemplateFragmentsResponse>} - A promise resolving to a page of template fragments.
   *
   * @example
   * Get a page of template fragments:
   * ```ts
   * const fragmentPage = await templateClient.getTemplateFragmentPage({
   *   templateId: '22f571c1-f41a-4db2-bba7-f23a069200c1',
   *   page: 1,
   *   pageSize: 10,
   * });
   * fragmentPage._embedded.template_fragments.forEach(fragment => {
   *   console.log(fragment.text);
   * });
   * ```
   */
  async getTemplateFragmentPage(params) {
    const resp = await this.sendGetRequest(
      `${this.config.apiHost}/v2/verify/templates/${params.templateId}/template_fragments`,
      {
        ...params.page ? { page: params.page } : {},
        ...params.pageSize ? { page_size: params.pageSize } : {}
      }
    );
    const fragments = (resp.data._embedded?.template_fragments || []).map(
      (fragment) => import_server_client.Client.transformers.camelCaseObjectKeys(fragment)
    );
    return {
      pageSize: resp.data.page_size,
      page: resp.data.page,
      totalPages: resp.data.total_pages,
      totalItems: resp.data.total_items,
      fragments,
      links: resp.data._links
    };
  }
  /**
   * Generator function to list all templates across multiple pages.
   *
   * @remarks
   * This will continue calling the API to retrieve all templates until there are no more pages left.
   * The function yields each template in camelCase format.
   *
   * @param {ListAllTemplateFragmentsParams} [params={}] - Optional filter parameters, including pagination.
   * @yields {TemplateFragment} - Yields each template object in camelCase format.
   *
   * @example
   * List all templates using pagination:
   * ```ts
   * for await (const template of templateClient.listAllTemplateFragments({ pageSize: 5 })) {
   *   console.log(template.name);
   * }
   * ```
   *
   * @example
   * List all templates without pagination:
   * ```ts
   * for await (const template of templateClient.listAllTemplateFragments()) {
   *   console.log(template.name);
   * }
   * ```
   */
  async *listAllTemplateFragments(params) {
    let next = null;
    params.page = params?.page || 1;
    do {
      const resp = await this.getTemplateFragmentPage(params);
      yield* resp.fragments || [];
      next = resp.links?.next;
      params.page++;
    } while (next);
  }
  /**
   * Retrieves a single template fragment by its unique identifier.
   *
   * @param {string} templateId - The unique identifier of the template.
   * @param {string} fragmentId - The unique identifier of the template fragment.
   * @return {Promise<TemplateFragmentResponse>} - A promise resolving to the retrieved template fragment in snake_case format.
   *
   * @example
   * Get a template fragment by ID:
   * ```ts
   * const fragment = await templateClient.getTemplateFragment('22f571c1-f41a-4db2-bba7-f23a069200c1', 'c70f446e-997a-4313-a081-60a02a31dc19');
   * console.log(fragment.text);
   * ```
   */
  async getTemplateFragment(templateId, fragmentId) {
    const resp = await this.sendGetRequest(
      `${this.config.apiHost}/v2/verify/templates/${templateId}/template_fragments/${fragmentId}`
    );
    return import_server_client.Client.transformers.camelCaseObjectKeys(resp.data, true);
  }
  /**
   * Creates a new template fragment with the provided details.
   *
   * @param {string} templateId - The unique identifier of the template to which the fragment belongs.
   * @param {TemplateFragment} fragment - The details of the template fragment to be created.
   * @return {Promise<TemplateFragment>} - A promise resolving to the created template fragment in camelCase format.
   *
   * @example
   * Create a new template fragment:
   * ```ts
   * const newFragment = await templateClient.createTemplateFragment(
   *   '22f571c1-f41a-4db2-bba7-f23a069200c1',
   *   {
   *     channel: 'sms',
   *     locale: 'en-us',
   *     text: 'Your verification code is ${code}',
   *   },
   * );
   * console.log(newFragment.text);
   * ```
   */
  async createTemplateFragment(templateId, fragment) {
    const resp = await this.sendPostRequest(
      `${this.config.apiHost}/v2/verify/templates/${templateId}/template_fragments`,
      {
        channel: fragment.channel,
        locale: fragment.locale,
        text: fragment.text
      }
    );
    return import_server_client.Client.transformers.camelCaseObjectKeys(resp.data);
  }
  /**
   * Deletes a template fragment by its unique identifier.
   *
   * @param {string} templateId - The unique identifier of the template to delete.
   * @param {string} fragmentId - The unique identifier of the template to delete.
   * @return {Promise<true>} - A promise that resolves when the template is successfully deleted.
   *
   * @example
   * Delete a template by ID:
   * ```ts
   * await templateClient.deleteTemplateFragment(
   *   '22f571c1-f41a-4db2-bba7-f23a069200c1'
   *   'c70f446e-997a-4313-a081-60a02a31dc19',
   * );
   * console.log('Template Fragment deleted successfully');
   * ```
   */
  async deleteTemplateFragment(templateId, fragmentId) {
    await this.sendDeleteRequest(
      `${this.config.apiHost}/v2/verify/templates/${templateId}/template_fragments/${fragmentId}`
    );
    return true;
  }
  /**
   * Updates an existing template with the provided details.
   *
   * @param {String} templateId - The ID of the template this fragment belongs to.
   * @param {TemplateFragment} fragment - The full template fragment object with updated details.
   * @return {Promise<TemplateFragment>} - A promise resolving to the updated template fragment in camelCase format.
   *
   * @example
   * Update a template:
   * ```ts
   * const updatedTemplateFragment = await templateClient.updateTemplateFragment(
   *  '22f571c1-f41a-4db2-bba7-f23a069200c1',
   *   {
   *     templateId: '22f571c1-f41a-4db2-bba7-f23a069200c1',
   *     name: 'Updated Template Name',
   *     isDefault: false,
   *   }
   * );
   * console.log(updatedTemplateFragment.name);
   * ```
   */
  async updateTemplateFragment(templateId, fragment) {
    if (!fragment.templateFragmentId) {
      throw new Error("Template Fragment ID is required for updating a template fragment");
    }
    const resp = await this.sendPatchRequest(
      `${this.config.apiHost}/v2/verify/templates/${templateId}/template_fragments/${fragment.templateFragmentId}`,
      {
        text: fragment.text
      }
    );
    return import_server_client.Client.transformers.camelCaseObjectKeys(resp.data);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Channels,
  EventStatus,
  RequestStatus,
  RequestWorkflowStatus,
  SilentAuthChannel,
  SilentAuthStatus,
  Verify2,
  VerifyLocale
});
